# @PathVariable vs @RequestParam
\
 
Spring을 사용하다 보면 Controller 단에서 클라이언트에서 URL에 파라미터를 같이 전달하는 경우가 있다. 주로 사용하는 형태는 아래의 두 가지가 대표적인 케이스가 있다.

> ex1) http://127.0.0.1?index=1&page=2
\
  ex2) http://127.0.0.1/index/1
>
- Type 1의 경우 파라메터의 값과 이름을 함께 전달하는 방식으로 게시판 등에서 페이지 및 검색 정보를 함께 전달하는 방식을 사용할 때 많이 사용한다.
- Type 2의 경우 Rest api에서 값을 호출할 때 주로 많이 사용한다.

Spring에서는 이러한 전달인자를 처리하는데 두 가지 방법을 제공한다.

## @PathVariable?
\
IoC는 Inversion of Control을 줄인 표현이다. 지금까지 자바코드를 작성해 객체를 생성할 때는 객체가 필요한 곳에서 직접 생성했을 것이다. 다음을 보면 클래스 B객체를 사용하기 위해 클래스 A에서 객체를 직접 생성한다.

*ex)클래스 A에서 클래스B객체 생성 예*

```java
public class A{
    b = new B();   //클래스A에서 new 키워드로 클래스 B의 객체 생성
}
```

**제어의 역전은 다른 객체를 직접 생성하거나 제어하는 것이 아니라 외부에서 관리하는 객체를 가져와 사용하는 것을 말한다.**
위 예제에 제어의 역전을 적용하면 다음과 같은 코드의 형태로 바뀐다. 이전과는 다르게 클래스 B객체를 직접 생성하는 것이 아니므로, 어딘가에서 받아와 사용하고 있다고 추측해볼 수 있다. 실제로 스프링은 스프링 컨테이너가 객체를 관리, 제공하는 역할을 한다.

```java
public class A{
private B b;  //코드에서 객체를 생성하지 않음, 어디선가 받아온 객체를 b에 할당
}
```
\
\
\



## @RequestParam?
앞에서 설명한 것처럼 스프링에서는 객체들을 관리하기 위해 제어의 역전을 사용한다. 그리고 제어의 역전을 구현하기 위해 사용하는 방법이 DI이다. DI는 Dependency Injection을 줄인 표현이고, 직역하면 의존성 주입이다.

**DI는 어떤 클래스가 다른 클래스에 의존한다는 뜻이다.** 조금 어려운 표현일 수도 있지만, 이것도 코드를 통해 보면 매우 쉽다. 다음은 Ioc/DI를 기초로 하는 스프링 코드입니다. 여기에서 사용하는 @Autowired라는 애너테이션은 스프링 컨테이너에 있는 빈이라는 것을 주입하는 역할을 하는데, 빈은 쉽게 말해 스프링 컨테이너에서 관리하는 객체를 말한다. 이전 코드에서는 개발자가 직접 B객체를 생성했지만 다음 코드는 어딘가에서 B b;라고 선언했을 뿐 직접 객체를 생성하지는 않고 있다. 다시 말해 객체를 주입받고 있다.
\
\

*ex)객체를 주입받는 모습 예*
```java
public class A{
//A에서 B를 주입받음
@Autowired
B b;
}
```

- 이렇게 코드를 작성해도 프로그램은 잘 동작한다. 그 이유는 스프링 컨테이너라는 곳에서 객체를 주입했기 때문이다. 쉽게 말해 스프링 컨테이너가 B객체를 만들어서 클래스 A에 준 것.

![image](https://github.com/Chae-space/java-algo/assets/90403366/969e0ffa-3363-492c-a2f3-693f1be40e99)

그림처럼 기존의 자바 코드는 클래스 A에서 B객체를 쓰고 싶은 경우 직접 생성했지만, 스프링의 경우 클래스 A에서 B객체를 쓰고 싶은 경우 객체를 직접 생성하는 것이 아니라 스프링 컨테이너에서 객체를 주입받아 사용한다. 이 IoC/DI개념은 스프링의 핵심 개념이라고 할 수 있을 만큼 중요하기 때문에 반드시 이해하고 넘어가야 한다.

